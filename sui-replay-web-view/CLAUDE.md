# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with the Sui Replay Web Viewer.

## Project Overview

This is a **pure frontend web application** with zero dependencies. All code is vanilla JavaScript, HTML, and CSS.

**Purpose:** Visual analysis tool for Sui transaction replay data generated by the `sui-replay-2` tool from the main Sui repository.

**Technology Stack:**
- Vanilla JavaScript (ES6+)
- HTML5 (File System Access API)
- CSS3 (Dark theme)
- No build tools, no dependencies, no npm packages

## Essential Development Commands

### Running the Web Viewer

```bash
# Simple method - open directly
open index.html

# Recommended - use local server to avoid CORS issues
python3 -m http.server 8000
# Then navigate to http://localhost:8000
```

### Testing

```bash
# Open unit tests in browser
open test-transaction-model.html
# Tests run automatically and display results in the browser
```

### Linting and Formatting

```bash
# No linters configured yet - this is vanilla JS
# Future: Consider adding ESLint or Prettier if needed
```

## File Structure

```
sui-replay-web-view/
├── index.html                          # Main application entry point
├── styles.css                          # Dark theme styling
├── transaction-viewer.js               # Main UI controller and rendering
├── transaction-model.js                # Data models and validation
├── test-transaction-model.html         # Unit tests
├── TRANSACTION_MODEL_VERIFICATION.md   # Model verification docs
├── REPLAY_DIR_README.md               # Template for replay output directories
├── README.md                          # User documentation
└── CLAUDE.md                          # This file
```

## Analysis Tabs

The web viewer provides five analysis tabs:

1. **Overview** - Transaction metadata, PTB command breakdown with full type information, gas summary
2. **Objects Touched** - All objects and packages loaded during execution
3. **Object Changes** - State changes (created/deleted/modified objects)
4. **Gas Analysis** - Detailed gas costs and per-object breakdown
5. **Raw Json** - All original JSON files from the replay directory

## Architecture Guidelines

### Domain-Driven Design Architecture

The codebase uses a **clean object-oriented architecture** with proper TypeScript-style domain models. This architecture separates concerns and provides a single source of truth for data representation.

### Code Organization

**Two-Layer Architecture:**

1. **Domain Layer** (`transaction-model.js`):
   - Pure data models with no DOM dependencies
   - Business logic for type parsing, command construction, and data validation
   - Core domain classes: `MoveType`, `MoveFunction`, `Command`, `Transaction`

2. **UI Layer** (`transaction-viewer.js`):
   - File loading and tab management
   - DOM rendering using domain models
   - No ad-hoc string manipulation for types or commands

**No External Dependencies:**
- Use vanilla JavaScript features only
- Prefer modern browser APIs (File System Access API, etc.)
- No jQuery, no React, no bundlers

### Core Domain Model Classes

#### **MoveType** - Represents a Move type with full package information

**Properties:**
- `package`: Package address (null for primitives)
- `module`: Module name
- `name`: Type name
- `typeArgs[]`: Array of nested MoveType instances
- `isPrimitive`: Boolean flag for built-in types

**Key Methods:**
- `toDisplayString()` → `module::Type<Args>` (short form)
- `toFullyQualifiedString()` → `0xPackage::module::Type<Args>` (full form)
- `toHTML()` → Formatted HTML with tooltips showing full package addresses
- `static fromTypeStructure(typeObj, cacheData)` → Parses JSON into MoveType

**Type Format Support:**
- Lowercase `struct` format (from command type_arguments)
- Capitalized `Struct` format (from object types)
- `DatatypeInstantiation` format (from object types with type args)
- Primitives: bool, u8, u16, u32, u64, u128, u256, address, signer
- Built-in generics: vector<T> (treated as primitive with type args)
- References: &T and &mut T

**Example Usage:**
```javascript
const coinType = MoveType.fromTypeStructure(typeObj, cacheData);
console.log(coinType.toDisplayString());        // "coin::Coin<sui::SUI>"
console.log(coinType.toFullyQualifiedString()); // "0x2::coin::Coin<0x2::sui::SUI>"
const html = coinType.toHTML();                  // HTML with hover tooltips
```

#### **MoveFunction** - Represents a Move function call

**Properties:**
- `package`: Package address
- `module`: Module name
- `name`: Function name
- `typeArgs[]`: Array of type argument MoveType instances

**Methods:** Same as MoveType for consistent formatting

**Example Usage:**
```javascript
const func = new MoveFunction(pkg, module, name, typeArgs);
console.log(func.toDisplayString()); // "coin::split<sui::SUI>"
```

#### **Command** - Base class for PTB commands

**Subclasses:**
- `MoveCallCommand` - Move function calls with type arguments
- `SplitCoinsCommand` - Coin splitting with inferred type
- `MergeCoinsCommand` - Coin merging with inferred type
- `MakeMoveVecCommand` - Vector construction with element type
- `TransferObjectsCommand` - Object transfers
- `PublishCommand` - Package publishing
- `UpgradeCommand` - Package upgrades

**Type Inference:**
Commands automatically resolve their type arguments from:
- Object types in cache (for object inputs)
- Type parameters from command structure
- Special case inference (gas coin = Coin<SUI>)

**Example - Adding a New Command Type:**
```javascript
class MyNewCommand extends Command {
    constructor(arg1, arg2, typeArgs = []) {
        super(typeArgs);
        this.arg1 = arg1;
        this.arg2 = arg2;
    }

    static fromRawCommand(rawCmd, transaction, inputs) {
        const [arg1, arg2] = rawCmd.MyNew;
        const typeArgs = []; // Resolve type args from context
        return new MyNewCommand(arg1, arg2, typeArgs);
    }
}
```

#### **Transaction** - Main transaction model

**Responsibilities:**
- Loads and unifies data from all 5 JSON files
- Provides clean API for accessing transaction data
- Single source of truth for all transaction information

**Key Methods:**
- `getCommands()` → Returns array of parsed Command objects
- `getObjectMoveType(objectId)` → Returns MoveType for an object
- `getInputs()` → Returns transaction inputs
- `getEffects()` → Returns transaction effects
- `getGasReport()` → Returns gas analysis data

**Example Usage:**
```javascript
const transaction = new Transaction(dataJson, effectsJson, gasJson, cacheJson, callInfoJson);
const commands = transaction.getCommands();
commands.forEach(cmd => {
    if (cmd instanceof MoveCallCommand) {
        console.log(cmd.function.toDisplayString());
    }
});
```

### Key Design Patterns

1. **Domain-Driven Design**: Business concepts (types, functions, commands) are first-class objects
2. **Single Source of Truth**: All type formatting goes through MoveType.toHTML()
3. **Type Safety**: Consistent handling of all Move types through domain classes
4. **Composition**: Commands contain MoveType instances, not raw strings
5. **Factory Pattern**: `fromRawCommand()` static methods construct command objects
6. **Pure Functions**: Data transformation methods have no side effects

### Command Return Type Inference (Critical!)

**Two-Pass Rendering System:**

PTB commands can reference results from previous commands (e.g., `Cmd_6` uses output from `Cmd_4`). To display correct type information:

1. **First Pass** (transaction-viewer.js ~line 2881): Populate `commandReturnTypes[i]` for ALL commands
   - MoveCall: Extract return types from `_signature.return_types` using `ptbTypeToString()`
   - SplitCoins: Array of coin types (one per split amount)
   - MakeMoveVec: `vector<ElementType>` from parsed command
   - Publish: Always `0x2::package::UpgradeCap`
   - TransferObjects/MergeCoins/Upgrade: `void`

2. **Second Pass** (transaction-viewer.js ~line 2917): Render commands with access to all return types
   - When formatting arguments, can call `inferCommandReturnType(cmdIndex, resultIndex)`
   - Returns the type string for `Cmd_X` or `Cmd_X.Y` (nested result)

**Critical:** Return types must be set in first pass BEFORE any rendering happens. Otherwise, later commands that reference earlier results will show "unknown".

**Special Type Handling:**

- **GasCoin**: When `argument === "GasCoin"`, always use `0x2::coin::Coin<0x2::sui::SUI>` (with full 64-char addresses)
- **Result/NestedResult**: Look up type via `inferCommandReturnType()`
- **Input objects**: Resolve type from object cache via `transaction.getObjectMoveType(objectId)`

**Key Function: `ptbTypeToString()`** (transaction-viewer.js ~line 3999)

Converts PTB signature type objects to fully qualified type strings:
- Handles primitives: `"Bool"`, `"U64"`, `"Address"`, etc.
- Handles references: `{"Reference": typeObj}` → `&T`
- Handles mutable references: `{"MutableReference": typeObj}` → `&mut T`
- Handles structs: `{"Datatype": ["0x2", "coin", "Coin", []]}` → `0x2::coin::Coin`
- Handles generics: `{"DatatypeInstantiation": [[pkg, mod, name, []], typeArgs]}` → `pkg::mod::name<Args>`
- Handles type parameters: `{"TypeParameter": 0}` → `T0`

**Important:** Always includes package addresses in output for hover tooltips to work correctly.

## Comment Writing Guidelines

**Do NOT comment the obvious** - comments should not simply repeat what the code does.

**When to comment:**
- Non-obvious algorithms or business logic
- Temporary exclusions, timeouts, or thresholds and their reasoning
- Complex calculations where the "why" isn't immediately clear
- Browser compatibility considerations or API limitations
- Assumptions about external state or data structure

**When NOT to comment:**
- Simple variable assignments
- Standard JavaScript patterns
- Self-descriptive function calls
- Basic DOM manipulation
- Obvious event handlers

## Development Best Practices

### Code Style

- Use `const` by default, `let` when mutation is needed
- Prefer template literals for string concatenation
- Use arrow functions for callbacks
- Keep functions small and focused
- Meaningful variable names over comments

### Testing

- All new data models should have tests in `test-transaction-model.html`
- Test edge cases: missing data, malformed JSON, empty arrays
- Visual testing: verify rendering in multiple browsers

### Browser Compatibility

- Target modern browsers (Chrome, Firefox, Safari latest versions)
- Use File System Access API (may not work in all browsers)
- Graceful degradation for missing features
- Test in at least Chrome and Firefox

### Performance Considerations

- Keep rendering functions efficient (avoid unnecessary DOM manipulation)
- Cache expensive computations
- Be mindful of large transaction datasets
- Profile with browser DevTools when performance issues arise

## Common Patterns and Best Practices

### Working with Types

**DO:**
```javascript
// Use domain model to get type as HTML
const typeHtml = moveType.toHTML();

// Parse type from JSON structure
const type = MoveType.fromTypeStructure(typeObj, cacheData);

// Get display string for logging
console.log(type.toDisplayString());
```

**DON'T:**
```javascript
// Don't manually format type strings
const typeStr = `${module}::${name}`; // ❌ Use moveType.toDisplayString() instead

// Don't build HTML manually
const html = `<span>${type}</span>`; // ❌ Use moveType.toHTML() instead
```

### Working with Commands

**DO:**
```javascript
// Use parsed commands from transaction model
const commands = transaction.getCommands();
commands.forEach(cmd => {
    if (cmd instanceof SplitCoinsCommand && cmd.coinType) {
        const typeHtml = cmd.coinType.toHTML();
        // Render with proper type information
    }
});
```

**DON'T:**
```javascript
// Don't parse commands manually
const rawCmd = txData.transactions[0]; // ❌ Use transaction.getCommands() instead
```

### Type Parsing Pitfalls

**TWO Type Systems in the Codebase:**

This codebase uses **two parallel type representations**:

1. **Domain Model (transaction-model.js):**
   - `MoveType` class parses JSON type objects
   - Methods: `fromTypeStructure()`, `toHTML()`, `toDisplayString()`
   - Used for: Parsing transaction data, object cache, command type arguments

2. **String Parser (transaction-viewer.js):**
   - `parseTypeString()` function parses type strings
   - Used for: Creating tooltips from type strings, inferring command return types
   - Must support both 2-part (`coin::Coin`) and 3-part (`0x2::coin::Coin`) formats
   - Must handle both simple types and generics with type arguments

**Why Two Systems?**
- JSON parsing (MoveType): Handles structured type objects from replay data
- String parsing (parseTypeString): Handles type strings from signatures and return type inference

**Both must stay in sync** to support the same type formats.

**Multiple JSON Type Format Support:**
The JSON data contains types in multiple formats. Always use `MoveType.fromTypeStructure()` which handles:

1. **Lowercase struct** (from command type_arguments):
```json
{"struct": {"address": "0x2", "module": "coin", "name": "COIN", "type_args": []}}
```

2. **Capitalized Struct** (from object types without type args):
```json
{"Struct": [["0x2", "sui", "SUI", []]]}
```

3. **DatatypeInstantiation** (from object types with type args):
```json
{"DatatypeInstantiation": [["0x2", "coin", "Coin", []], [...]]}
```

4. **Datatype** (from PTB signatures without type args):
```json
{"Datatype": ["0x2", "sui", "SUI", []]}
```

**Primitive Type Handling:**
Primitives (bool, u8-u256, address, signer, vector) have `package = null`. Always check `isPrimitive` flag before accessing package:

```javascript
// Correct null-safe approach
if (!type.isPrimitive && type.package) {
    const pkg = type.package.startsWith('0x') ? type.package : `0x${type.package}`;
    // Use package
}
```

### Extending the Codebase

**Adding a New Command Type:**

1. Create command class extending `Command`:
```javascript
class NewCommand extends Command {
    constructor(arg, typeArgs = []) {
        super(typeArgs);
        this.arg = arg;
    }

    static fromRawCommand(rawCmd, transaction, inputs) {
        const arg = rawCmd.New;
        // Resolve type arguments from context if needed
        const typeArgs = [];
        return new NewCommand(arg, typeArgs);
    }
}
```

2. Add to `Transaction.getCommands()` switch statement:
```javascript
case 'New':
    return NewCommand.fromRawCommand(cmd, this, inputs);
```

3. Update UI rendering in `transaction-viewer.js` to handle the new command type.

**Adding Type Information to Commands:**

If your command operates on typed objects, resolve the type from the object cache:

```javascript
static fromRawCommand(rawCmd, transaction, inputs) {
    const objectArg = rawCmd.New.object;
    let objectType = null;

    if (objectArg.Input !== undefined && inputs && inputs[objectArg.Input]) {
        const inputObj = inputs[objectArg.Input].Object;
        if (inputObj && inputObj.ImmOrOwnedObject) {
            const objectId = inputObj.ImmOrOwnedObject[0];
            objectType = transaction.getObjectMoveType(objectId);
        }
    }

    return new NewCommand(objectArg, objectType);
}
```

## Integration with Sui Repository

**Related Tool:** `sui-replay-2` in https://github.com/MystenLabs/sui at `crates/sui-replay-2/`

**Data Flow:**
1. `sui-replay-2` executes transaction and dumps JSON artifacts
2. JSON files are written to `path_replay_runs_from/.replay/<TX_DIGEST>/`
3. This web viewer loads and analyzes those JSON files

**Expected Input Files:**
- `transaction_data.json` - Transaction structure and inputs
- `transaction_effects.json` - Execution results and state changes
- `transaction_gas_report.json` - Gas usage breakdown
- `replay_cache_summary.json` - Cached objects and packages, epoch, checkpoint, protocol version
- `move_call_info.json` - Move call function signatures with parameter/return types (optional but recommended)

**Test Data Location:**
When the user references a transaction by digest (e.g., "transaction 3a6CnuW..."), the artifacts are located at:
```
/Users/dariorussi/sui/crates/sui-replay-2/.replay/<TX_DIGEST>/
```
You have read access to this directory to examine test data and verify fixes.

## Future Enhancements

Potential areas for improvement:
- Add ESLint/Prettier for code consistency
- TypeScript conversion for better type safety
- Unit testing framework (Jest or similar)
- Better error handling and user feedback
- Export analysis results to JSON/CSV
- Comparison view for multiple transactions
- Search/filter functionality for large object lists

## Notes for Claude Code

### General Guidelines

- This is a standalone project separate from the main Sui repository
- Changes here do NOT affect the Sui blockchain or replay tool
- No build step needed - edit files and refresh browser
- Keep the zero-dependency philosophy
- Prioritize simplicity and browser compatibility over fancy frameworks

### Architecture Principles

**Always use the domain model:**
- Never manually format types - use `MoveType.toHTML()` or `toDisplayString()`
- Never parse commands directly - use `transaction.getCommands()`
- Domain models are the single source of truth

**When adding features:**
1. Consider if it belongs in the domain layer (transaction-model.js) or UI layer (transaction-viewer.js)
2. Add domain logic to transaction-model.js as pure functions
3. Add rendering logic to transaction-viewer.js using the domain model
4. Update tests in test-transaction-model.html for new domain logic

**When fixing bugs:**
1. Check if the issue is in type parsing (`MoveType.fromTypeStructure`)
2. Verify null safety for primitive types (they have `package = null`)
3. Ensure all type format variants are supported (lowercase struct, capitalized Struct, DatatypeInstantiation)
4. Test with multiple transactions to catch edge cases

### Common Issues and Solutions

**Issue:** Types showing as "unknown::unknown"
**Cause:** `MoveType.fromTypeStructure()` doesn't handle a type format variant
**Solution:** Add support for the new format in the parsing logic, maintaining the same return type

**Issue:** "Cannot read properties of null" on package
**Cause:** Primitive types have `package = null`
**Solution:** Check `isPrimitive` flag or add null checks before accessing package

**Issue:** Type arguments not showing correctly
**Cause:** Not recursively parsing nested type arguments
**Solution:** Use `MoveType.fromTypeStructure()` recursively for type_args arrays

**Issue:** Command type information missing
**Cause:** Not resolving type from object cache
**Solution:** Use `transaction.getObjectMoveType(objectId)` to resolve object types

**Issue:** Command results showing as "unknown" when referenced by later commands
**Cause:** `parseTypeString()` in transaction-viewer.js doesn't handle the type string format
**Solution:** The viewer uses TWO type systems:
- Domain model (MoveType) for parsing JSON → used in transaction-model.js
- String parser (parseTypeString) for parsing type strings → used in transaction-viewer.js for tooltips
Both must support the same formats. Type strings can be either 2-part (`coin::Coin`) or 3-part fully qualified (`0x2::coin::Coin`)

### Version Management

When making changes that affect rendering:
1. Increment the version parameter in index.html script tags (e.g., `?v=57` → `?v=58`)
2. This forces browser cache refresh for users
3. Keep version numbers in sync between transaction-model.js and transaction-viewer.js

### Testing Checklist

Before submitting changes:
- [ ] Test with multiple transactions (different PTB command types)
- [ ] Verify types display correctly (module::Type format with tooltips)
- [ ] Check that primitives render without package addresses
- [ ] Ensure complex nested types (e.g., `Coin<Balance<SUI>>`) parse correctly
- [ ] Test in Chrome and Firefox
- [ ] Verify no console errors
- [ ] Check that unit tests pass (open test-transaction-model.html)
